/**
 * @file Defines the self-contained classes that mainly represent data and operations on them
 */

/**
 * Class representing a collection of a function (of one variable) 
 *   with its derivative (as an expression of both x and y)
 * The expression is in the form: $ y' = f(x, y) $, where f(x, y) is the function given here
 */
export class DifferentialFunction {
	/**
	 * @callback actualFunction
	 * @param {number} x
	 * @returns {number}
	 */
	/**
	 * @callback derivative
	 * @param {number} x
	 * @param {number} y
	 * @returns {number}
	 */

	/**
	 * Constructor
	 * @param { actualFunction } actual The solution of the differential equation 
	 * @param { derivative } derivative The expression y'(x, y)
	 */
	constructor(actual, derivative) {
		/** @const @private */
		this._actual = actual;

		/** @const @private */
		this._df = derivative;
	}

	/**
	 * A method that gets the value of the actual solution at the input [x]
	 * @param {number} x 
	 * @returns {number} y
	 */
	exact(x) {
		if (arguments.length !== 1)
			throw 'f is a function of x only!';
		return this._actual(x);
	}

	/**
	 * A method that gets the value of y'(x, y)
	 * @param {number} x
	 * @param {number} y
	 * @returns {number}
	 */
	derivative(x, y) {
		if (arguments.length !== 2)
			throw 'f\' is in terms of x and y';
		return this._df(x, y);
	}
}


/**
 * Object containing configuration of numerical methods
 * @typedef {Object} Config
 * @property {number} config.x0 The start of the domain of the function
 * @property {number} config.y0 The value of the solution of the function at [x0]
 * @property {number} config.X The end of the domain of the function
 * @property {number} config.h The step to use for the methods
 */
/**
 * Wrapper for a point with x-y coordinates
 * @typedef {Object} point
 * @property {number} x The value of the x-coordinate
 * @property {number} y The value of the x-coordinate
 */

/**
 * A collection of the different numerical approximation methods, applied to a single given function
 */
export class NumericalMethods {
	/**
	 * Initializes the function with the given values
	 * @param {derivative} f The expression in terms of both x and y
	 * @param {Config} [config] The default config to apply to all methods if not provided otherwise
	 */
	constructor(f, config) {
		if (typeof f !== 'function')
			throw 'Please pass a function to the constructor';
		this.f = f;
		if (config) {
			this.x0 = config.x0;
			this.y0 = config.y0;
			this.X = config.X;
			this.h = config.h;
		}
	}

	/**
	 * Represents taking one step of the Euler method
	 * @param {number} x x-coordinate of the given point
	 * @param {number} y y-coordinate of the given point
	 * @param {number} h step to move [x] by
	 * @returns {point} An object containing the next values of x and y
	 */
	eulerStep(x, y, h) {
		return {
			y: y + h * this.f(x, y),
			x: x + h,
		};
	}
	/**
	 * Runs the [eulerStep] method until it reaches [X]
	 * @param {Config} [config] Optionally override the configuration given to the constructor
	 */
	euler(config) {
		return this._wrap(this.eulerStep.bind(this), { ...config });
	}

	/**
	 * Represents taking one step on the Improved-Euler method
	 * @param {number} x x-coordinate of the given point
	 * @param {number} y y-coordinate of the given point
	 * @param {number} h step to move [x] by
	 * @returns {point} An object containing the next values of x and y
	 */
	improvedEulerStep(x, y, h) {
		const k1 = this.f(x, y);
		const k2 = this.f(x + h, y + h * k1);
		return {
			y: y + (h / 2) * (k1 + k2),
			x: x + h,
		};
	}
	/**
	 * Runs the [improvedEulerStep] method until it reaches [X]
	 * @param {Config} [config] Optionally override the configuration given to the constructor
	 */
	improvedEuler(config) {
		return this._wrap(this.improvedEulerStep.bind(this), { ...config });
	}

	/**
	 * Represents taking one step on the Runge-Kutta method
	 * @param {number} x x-coordinate of the given point
	 * @param {number} y y-coordinate of the given point
	 * @param {number} h step to move [x] by
	 * @returns {point} An object containing the next values of x and y
	 */
	rungeKuttaStep(x, y, h) {
		const k1 = h * this.f(x, y);
		const k2 = h * this.f(x + h / 2, y + k1 / 2);
		const k3 = h * this.f(x + h / 2, y + k2 / 2);
		const k4 = h * this.f(x + h, y + k3);
		return {
			y: y + (1 / 6) * (k1 + 2 * k2 + 2 * k3 + k4),
			x: x + h,
		};
	}
	/**
	 * Runs the [rungeKuttaStep] method until it reaches [X]
	 * @param {Config} [config] Optionally override the configuration given to the constructor
	 */
	rungeKutta(config) {
		return this._wrap(this.rungeKuttaStep.bind(this), { ...config })
	}

	/**
	 * Runs a given function from [x0] till [X], returning 
	 * @param {function(number, number, number): point} f The function to run till end
	 * @param {Config} config Overrides 
	 * @returns {point[]} The points generated by the given function
	 */
	_wrap(f, { x0, y0, X, h }) {
		x0 = x0 || this.x0;
		y0 = y0 || this.y0;
		X = X || this.X;
		h = h || this.h;

		if (h == 0)
			return [];

		/** @type {point[]} */
		let data = [];
		while (x0 <= X) {
			data.push({ x: x0, y: y0 });
			({ x: x0, y: y0 } = f(x0, y0, h));
		}
		return data;
	}
}
